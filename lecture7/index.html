<!DOCTYPE html>
<html lang="en">
<head>
    <title>HSE DB Course. Lecture 7.</title>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="shower/themes/yandex/styles/screen-16x9.css">

    <style type="text/css">
        code { display: block; white-space: pre; background-color: #EEE; }
        p.cloud { text-align: center; line-height: 1.5; }
        p.cloud span { font-size: 13pt; color: gray; padding: 0 20px 0 20px; white-space: nowrap; }
   </style>
</head>
<body class="shower list">
    <header class="caption">
        <h1>Базы данных 2022</h1>
    </header>

    <section class="slide" id="cover">
        <h1 style="margin-top: 150px;">Лекция 7. B-Tree Indexes. Part 1.</h1>
    </section>

    <section class="slide">
        <h2>План</h2>
        <p>1. Table Indexes.</p>
        <p>2. B-Tree Family.</p>
        <p>3. B+-Tree Overview.</p>
        <p>4. Clustered/Non Clustered Indexes.</p>
        <p>5. Selection Conditions.</p>
        <p>6. B+-Tree Properties.</p>
    </section>

    <section class="slide">
        <h1>Table Indexes</h1>

        <p>Индекс таблицы — это копия подмножества атрибутов таблицы, которые организованы и/или отсортированы для эффективного
            доступа используя часть атрибутов по которым построен индекс.</p>
        <p>СУБД обеспечивает логическую синхронизацию содержимого таблицы и индекса.</p>
    </section>

    <section class="slide">
        <h1>Table Indexes</h1>

        <p>Задача СУБД состоит в том, чтобы выяснить, какие индексы лучше всего использовать для выполнения каждого запроса.</p>
        <p>Существует компромисс при выборе индексов для каждой базы данных.</p>
        <p>1. Накладные расходы на хранение данных индексов.</p>
        <p>2. Накладные расходы на поддержку синхронизации между данными таблицы и индексами.</p>
    </section>

    <section class="slide">
        <h1>B-Tree Family</h1>
        <p>Существует определенная структура данных, называемая B-Tree.</p>
        <p>Термин часто используется для обозначения класса сбалансированных древовидных структур данных.</p>
        <p>1. B-Tree (1971)</p>
        <p>2. B+Tree (1973)</p>
        <p>3. B*Tree (1977)</p>
        <p>4. B-Link-Tree (1981)</p>
    </section>

    <section class="slide">
        <h1>B+-Tree Overview</h1>

        <p>B+Tree — это самобалансирующаяся древовидная структура данных, которая поддерживает сортировку данных и позволяет осуществлять поиск, последовательный доступ,
вставки и удаления в <b>O(log n)</b>.</p>
        <p>Обобщение бинарного дерева поиска. Узел может иметь более двух детей.</p>
        <p>Оптимизирована для систем, которые читают и пишут большие блоки данных.</p>
    </section>

    <section class="slide">
        <h1>B+-Tree Overview</h1>

        <img style="width: 80%; height: 60%;" src="pictures/bplus_tree.png"/>
    </section>

    <section class="slide">
        <h1>B+-Tree Overview</h1>
        <p>B+Tree — это <b>M</b>>-дерево поиска с следующими свойствами:</p>
        <p>1. Он идеально сбалансирован (т. е. каждый листовой узел находится на одной глубине)</p>
        <p>2. Каждый узел, кроме корня, заполнен как минимум наполовину</p>
        <p><b>M/2-1 ≤ #keys ≤ M-1</b></p>
        <p>3. Каждый внутренний узел с k ключами имеет k+1 ненулевых дочерних элементов</p>
    </section>

    <section class="slide">
        <h1>B+-Tree Overview</h1>
        <p>Каждый узел в B+Tree содержит массив пар ключ/значение:</p>
        <p>Массивы в каждом узле отсортированы по ключам.</p>
        <p>Массив значений для внутренних узлов будет содержать указатели на другие узлы.</p>
        <p>Ключи получаются из атрибутов(ов) таблицы, для которых построен индекс.</p>
        <p>Значения будут различаться в зависимости от того, классифицируются как внутренние узлы или листовые узлы.</p>
    </section>

    <section class="slide">
        <h1>B+-Tree Overview. Leaf Nodes.</h1>
        <p>Два подхода к значению листовых узлов.</p>
        <p>1. Идентификаторы записей: указатель на расположение кортежа. (PostgresSQL, Oracle)</p>
        <p>2. Данные кортежа: фактическое содержимое кортежа хранится в конечном узле. (MySQL, SQLite)</p>
    </section>

    <section class="slide">
        <h1>B+-Tree Overview. B-Tree comparison</h1>

        <p>B-Tree хранит ключи + значения во всех узлах дерева.</p>
        <p>Более эффективное использование пространства, так как каждый ключ появляется только один раз в дереве.</p>
        <p>B+Tree хранит значения только в листовых узлах. Внутренние узлы направляют процесс поиска.</p>
    </section>

    <section class="slide">
        <h1>B+-Tree Insertion</h1>
        <p>1. Найдите правильный лист L.</p>
        <p>2. Добавьте новую запись в L в порядке сортировки:</p>
        <p>Если в L достаточно места, операция выполнена.</p>
        <p>В противном случае разбиваем L на два узла L и L2. Равномерно распределяем ключи и значения в записи и копируем средний ключ на уровень вверх.</p>
        <p>Вставляем указатель на L2, в родительский элемент L.</p>
        <p>3. Чтобы разделить внутренний узел, перераспределите записи поровну, затем необходимо поднять средний ключ наверх.</p>
    </section>

    <section class="slide">
        <h1>B+-Tree Deletion</h1>

        <p>Начиная с корня, найдите лист L, которому принадлежит запись. Удалите запись.</p>
        <p>Если L заполнен хотя бы наполовину, готово.</p>
        <p>Если L имеет только записи <b>M/2-1</b>.</p>
        <p>Попробуйте перераспределить ключи, заимствуя соседнего узел с тем же родителем, что и L.
        <p>Если распределение не удается, объедините L и соседний узел. (Merge)</p>
        <p>Если произошло слияние (Merge), необходимо удалить запись (указывающую на L, или соседний узел) из родителя L.</p>
    </section>

    <section class="slide">
        <h1>B+-Tree</h1>

        <p>Типичный коэффициент заполнения: 67%.</p>
        <p>Типичные емкости:</p>
        <p>Высота 4: 1334 = 312 900 721 запись</p>
        <p>Высота 3: 1333 = 2 406 104 записи</p>
        <p>Страниц на уровень:</p>
        <p>Уровень 1 = 1 страница = 8 КБ</p>
        <p>Уровень 2 = 134 страницы = 1 МБ</p>
        <p>Уровень 3 = 17 956 страниц = 140 МБ</p>
    </section>

    <section class="slide">
        <h1>Clustered Indexes</h1>

        <p>Таблица хранится в порядке сортировки, заданном первичным ключом.</p>
        <p>Может быть хранилищем с кучей или индексом.</p>
        <p>Некоторые СУБД всегда используют кластерный индекс (MySQL).</p>
        <p>Если таблица не содержит первичного ключа, СУБД автоматически сделать первичный ключ идентификатора скрытой строки.</p>
    </section>

    <section class="slide">
        <h1>Selection Conditions</h1>

        <p>СУБД может использовать индекс B+Tree, если запрос содержит любой из атрибутов ключа поиска.</p>
        <p>Пример: Индекс на &lt;a,b,c&gt;.</p>
        <p>Поддерживается: (a=5 И b=3).</p>
        <p>Для хеш-индекса у нас должны быть все атрибуты в ключе поиска.</p>
    </section>

    <section class="slide">
        <h1>B+-Tree Properties</h1>

        <p>Размер узла (Node Size).</p>
        <p>Порог слияния (Merge Threshold).</p>
        <p>Ключи произвольной длины (Variable Lenght Keys).</p>
        <p>Неуникальные индексы (Non-Unique Keys).</p>
        <p>Поиск внутри узла (Intra-Node Search).</p>
    </section>

    <section class="slide">
        <h1>B+-Tree Node Size</h1>

        <p>Чем медленнее запоминающее устройство, тем больше оптимальный размер узла для B+Tree.</p>
        <p>Жесткий диск ~1 МБ</p>
        <p>SSD: ~10 КБ</p>
        <p>В памяти: ~512 байт</p>
        <p>Оптимальные размеры могут варьироваться в зависимости от рабочей нагрузки</p>
        <p>1. Сканирование листовых узлов (Sequential scan).</p>
        <p>2. Обходы от корня к листу (Key Lookup).</p>
    </section>

    <section class="slide">
        <h1>B+-Tree Merge Threshold</h1>

        <p>Некоторые СУБД не всегда объединяют узлы, когда они заполнены наполовину.</p>
        <p>Задержка операции слияния может уменьшить объем реорганизации.</p>
        <p>Также может быть лучше просто позволить существовать недорасходам хранилища, а затем периодически перестраивать все дерево.</p>
    </section>

    <section class="slide">
        <h1>B+-Tree Variable keys</h1>

        <p>1. Pointers</p>
        <p>Сохраняйте ключи как указатели на атрибут кортежа.</p>
        <p>2. Variable Length Nodes</p>
        <p>Размер каждого узла в индексе может варьироваться.</p>
        <p>3. Padding</p>
        <p>Всегда дополняем так, чтобы он соответствовал максимальной длине типа ключа (VARCHAR).</p>
        <p>4. Key Map/Indirection</p>
        <p>Используем массив указателей (Slotted Pages), которые сопоставляются со списком ключей и значений внутри узла.</p>
    </section>

    <section class="slide">
        <h1>B+-Tree Non Unique Keys</h1>

        <p>1. Duplicate Keys</p>
        <p>Используйте одну структуру узла, но храните повторяющиеся ключи несколько раз.</p>
        <p>2. Value Lists</p>
        <p>Хранить ключ только 1 раз и использовать список для хранения уникальных значений.</p>
    </section>

    <section class="slide">
        <h1>B+-Tree Intra Node Search</h1>

        <p>1. Linear</p>
        <p>Сканировать ключи узла от начала до конца.</p>
        <p>2. Binary Search</p>
        <p>Перейти к следующему ключу, повернуться влево/вправо в зависимости от сравнения.</p>
        <p>3. Interpolation</p>
        <p>Приблизительное расположение нужного ключа на основе известного распределения ключей.</p>
    </section>

    <section class="slide">
        <h1>Conclusion</h1>

        <p>B+Tree - структура данных, улучшение бинарного дерева поиска, оптимизированного для работы с медленным хранилищем.</p>
    </section>

    <section class="slide">
        <h1>Вопросы ?</h1>
    </section>

    <div class="progress"></div>
    <script src="shower/shower.min.js"></script>

    <!--Video plugin-->
    <link rel="stylesheet" href="shower/shower-video.css">
    <script src="shower/shower-video.js"></script>
    <!--/Video plugin-->
</body>
</html>
