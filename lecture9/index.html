<!DOCTYPE html>
<html lang="en">
<head>
    <title>HSE DB Course. Lecture 6.</title>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="shower/themes/yandex/styles/screen-16x9.css">

    <style type="text/css">
        code { display: block; white-space: pre; background-color: #EEE; }
        p.cloud { text-align: center; line-height: 1.5; }
        p.cloud span { font-size: 13pt; color: gray; padding: 0 20px 0 20px; white-space: nowrap; }
   </style>
</head>
<body class="shower list">
    <header class="caption">
        <h1>Базы данных 2022</h1>
    </header>

    <section class="slide" id="cover">
        <h1 style="margin-top: 150px;">Лекция 9. Multi-Threaded Index Concurrency Control</h1>
    </section>

    <section class="slide">
        <h2>План</h2>
        <p>1. Concurrency control.</p>
        <p>2. Locks. Latches.</p>
        <p>3. Latches.</p>
        <p>4. Hash-Table Latching.</p>
        <p>5. B+Tree Latching.</p>
    </section>

    <section class="slide">
        <h1>Concurrency control</h1>

        <p>Мы предполагали, что индексные структуры данных, которые мы обсуждали (Hash Table, B+Tree), являются однопоточными.</p>
        <p>Но нам нужно разрешить нескольким потокам безопасный доступ к нашим структурам данных, чтобы утилизировать все ядра процессора, и
            уменьшить влияние скорости дискового ввода-вывода.</p>
    </section>

    <section class="slide">
        <h1>Concurrency control</h1>

        <p>Протокол управления параллелизмом (Concurrency control) — это метод, который СУБД использует для обеспечения «правильных» результатов параллельных
            операций над общим объектом.</p>
        <p>Критерии корректности протокола могут различаться:</p>
        <p>Логическая корректность (Logical correctness): Могу ли я увидеть данные, которые я должен видеть ? Это означает, что поток может считывать значения,
            которые он должен прочитать.</p>
        <p>Физическая корректность (Physical correctness): Правильно ли физическое представление объекта? Это означает, что в нашей структуре данных нет указателей,
            которые заставят поток читать недопустимые ячейки памяти.</p>
    </section>

    <section class="slide">
        <h1>Locks</h1>

        <p>1. Защищает логическое содержимое индексов от других транзакций.</p>
        <p>2. Удерживается в течение (в основном) всего срока транзакции.</p>
        <p>3. СУБД должна иметь возможность откатывать изменения.</p>
        <p>4. Устойчивы к deadlock.</p>
    </section>

    <section class="slide">
        <h1>Latches</h1>

        <p>1. Защищает критические разделы внутренних структур данных СУБД от других потоков.</p>
        <p>2. Удерживается на время операции.</p>
        <p>3. СУБД не обязательно должна иметь возможность откатывать изменения.</p>
        <p>4. Неустойчивы к deadlock.</p>
    </section>

    <section class="slide">
        <h1>Latches</h1>

        <p>Режим чтения (Read mode)</p>
        <p>Несколько потоков могут иметь доступ к объекту на чтение.</p>
        <p>Режим записи</p>
        <p>Только один поток может иметь доступ к объекту на запись.</p>
    </section>

    <section class="slide">
        <h1>Latches</h1>

        <p>Базовый примитив, который мы можем использовать для реализации latches, это атомарные инструкция сравнения и замены (CAS), которую предоставляют современные процессоры.
        При этом поток может проверить содержимое области памяти, чтобы увидеть, имеет ли она определенное значение.
        Если это так, то ЦП заменит старое значение новым. В противном случае ячейка памяти остается неизменной.</p>

    </section>

    <section class="slide">
        <h1>Latches</h1>

        <p>Существует несколько подходов к реализации защелки в СУБД. Каждый подход имеет различные компромиссы с точки зрения инженерной сложности и производительности во время выполнения.
        Шаг проверки и захвата latch выполяется атомарно (т. е. ни один другой поток не может обновить значение после того, как один поток проверит его, но до того, как он его обновит).</p>
    </section>

    <section class="slide">
        <h1>Latches implementation</h1>

        <p>Вариант 1. Mutex</p>
        <p>Предоставляет интерфейс lock, unlock. Например std::mutex.</p>
        <p>Плохо масштабируется при большом количестве потоков.</p>
    </section>

    <section class="slide">
        <h1>Latches implementation</h1>

        <p>Вариант 2. TAS Spinlock.</p>
        <p>Предоставляет интерфейс lock, unlock.</p>
        <p>Можно реализовать с использованием std::atomic</p>
    </section>

    <section class="slide">
        <h1>Latches implementation</h1>

        <p>Вариант 3. Read-Write lock.</p>
        <p>Предоставляет интерфейс lock, unlock, lock_shared, unlock_shared. Например std::mutex</p>
        <p>Можно реализовать над std::mutex, или TAS Spinlock.</p>
    </section>

    <section class="slide">
        <h1>Hash-Table Latching</h1>

        <p>Простота поддержки одновременного доступа благодаря ограниченному способу доступа потоков к хеш-таблице.</p>
        <p>Все потоки движутся в одном направлении и обращаются только к по одной странице/слоту за раз.</p>
        <p>Взаимоблокировки невозможны.</p>
        <p>Для extendible хеш-таблицы, чтобы изменить размер таблицы, можно использовать глобальный latch на всей таблице (т. е. на странице с заголовком).</p>
        <p>Для static хеш-таблицы, можно использовать алгоритм lock striping.</p>
    </section>

    <section class="slide">
        <h1>B+Tree Latching</h1>

        <p>Мы хотим, чтобы несколько потоков одновременно читали и обновляли B+Tree. Нам необходимо защититься от двух типов проблем:</p>
        <p>Потоки, пытающиеся изменить содержимое узла в то же время.</p>
        <p>Один поток пересекает дерево, в то время как другой поток split/merge узлов.</p>
    </section>

    <section class="slide">
        <h1>B+Tree Latching. Lock crabbing</h1>
        <p>Lock crabbing/connection — это протокол, позволяющий нескольким потокам одновременно получать доступ к B+Tree или изменять его:</p>
        <p>1. Получить блокировку для родителя.</p>
        <p>2. Получить блокировку для ребенка.</p>
        <p>3. Отпустите блокировку для родителя, если родительский узел считается безопасным.</p>

        <p>Безопасный узел — это тот, который не будет разделяться или объединяться при обновлении (не будет заполнен при вставке или заполнен более чем наполовину при удалении).</p>
    </section>

    <section class="slide">
        <h1>B+Tree Latching. Lock crabbing</h1>
        <p>Протокол захвата блокировки:</p>
        <p>1. Поиск (Search): Начинаем с корня и спускаемся вниз, многократно захватывая блокировки дочерний элементов, а затем разблокируя блокировку родительского.</p>
        <p>2. Вставка/Удаление (Insert/Delete): Начинаем с корня и спускаемся вниз, захватывая блокировки по мере необходимости. Как только получена блокировка на дочерний элемент,
            необходимо проверить безопасный ли это узел, если безопасный отпускаем блокировки на всех его предках.</p>
    </section>

    <section class="slide">
        <h1>B+Tree Latching. Leaf nodes scan</h1>

        <p>Потоки в этих протоколах захватывали блокировки «сверху вниз». Это означает, что поток может получить блокировку только от узла, который находится ниже его текущего узла.</p>
        <p>Если желаемая блокировка захвачена, поток должен ждать, пока она не станет доступной. Учитывая это, никогда не может быть взаимоблокировок.</p>
    </section>

    <section class="slide">
        <h1>B+Tree Latching. Leaf nodes scan</h1>
        <p>Сканирование листовых узлов подвержено взаимоблокировкам, потому что теперь у нас есть потоки, пытающиеся получить блокировки в двух разных направлениях одновременно (т. е. слева направо и справа налево).</p>
        <p>Это означает, что если поток пытается получить блокировку на листовом узле, но эта блокировку недоступна,
            то он немедленно прервет свою операцию (освобождая все удерживаемые блокировки), а затем перезапустит операцию.</p>
    </section>

    <section class="slide">
        <h1>Conclusion</h1>

        <p>Concurrency control - протокол который необходимо поддерживать на уровне структуры данных..</p>
    </section>

    <section class="slide">
        <h1>Questions ?</h1>
    </section>

    <div class="progress"></div>
    <script src="shower/shower.min.js"></script>

    <!--Video plugin-->
    <link rel="stylesheet" href="shower/shower-video.css">
    <script src="shower/shower-video.js"></script>
    <!--/Video plugin-->
</body>
</html>
