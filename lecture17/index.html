<!DOCTYPE html>
<html lang="en">
<head>
    <title>HSE DB Course. Lecture 14.</title>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="shower/themes/yandex/styles/screen-16x9.css">

    <style type="text/css">
        code { display: block; white-space: pre; background-color: #EEE; }
        p.cloud { text-align: center; line-height: 1.5; }
        p.cloud span { font-size: 13pt; color: gray; padding: 0 20px 0 20px; white-space: nowrap; }
   </style>
</head>
<body class="shower list">
    <header class="caption">
        <h1>Базы данных 2022</h1>
    </header>

    <section class="slide" id="cover">
        <h1 style="margin-top: 150px;">Лекция 17. Two Phase Locking.</h1>
    </section>

    <section class="slide">
        <h2>План</h2>
        <p>1. Transaction Locks.</p>
        <p>2. Two-Phase Locking.</p>
        <p>3. Strong Strict Two-Phase Locking.</p>
        <p>4. Two-Phase Locking Deadlock Handling.</p>
        <p>5. Lock Granularities.</p>
    </section>

    <section class="slide">
        <h1>Transactions Basics</h1>

        <p>Транзакция — это выполнение последовательности одной или нескольких операций (например, SQL-запросов) в общей базе данных для выполнения какой-либо функции более высокого уровня.</p>
        <p>Они являются основной единицей работы в СУБД.</p>
        <p>Частичное выполнение транзакций не допускается.</p>
    </section>

    <section class="slide">
        <h1>Transaction Locks</h1>

        <p>СУБД содержит менеджер блокировок (LockManager), который принимает решение о том, может ли транзакция взять блокировку или нет.</p>
        <p>Менеджер блокировок имеет информацию о всех блокировках внутри системы.</p>
    </section>

    <section class="slide">
        <h1>Transaction Locks</h1>

        <p>Общая блокировка (Shared Lock, read-lock): блокировка, которая позволяет нескольким транзакциям читать один и тот же объект одновременно. Если одна транзакция удерживает общую блокировку, то другая транзакция также может получить эту же общую блокировку.</p>
        <p>Эксклюзивная блокировка (Exclusive Lock, write-lock): позволяет транзакции изменять объект. Эта блокировка не совместима с другими. Только одна транзакция может одновременно удерживать эксклюзивную блокировку.</p>
    </section>

    <section class="slide">
        <h1>Transaction Execution</h1>

        <p>1. Транзакции запрашивают блокировки (или upgrade) у менеджера блокировок.</p>
        <p>2. Диспетчер блокировок разрешает или блокирует запросы в зависимости от того, какие блокировки в настоящее время удерживаются другими транзакциями.</p>
        <p>3. Транзакции снимают блокировки, когда они им больше не нужны.</p>
        <p>4. Менеджер блокировок обновляет свою внутреннюю таблицу блокировок, а затем блокирует ожидающие транзакции.</p>
        </section>

    <section class="slide">
        <h1>Transactions Basics</h1>

        <p>Выполнение параллельных транзакций в СУБД является сложной задачей.</p>
        <p>Трудно обеспечить корректность транзакции при высокой конкуретности запросов.</p>
        <p>1. Временная неконсистентность в данных допустима.</p>
        <p>2. Полная неконсистентность в данных недопустима.</p>
    </section>

    <section class="slide">
        <h1>Two Phase Locking</h1>

        <p>Двухфазная блокировка (2PL) — это пессимистичный протокол управления параллелизмом, который определяет, разрешен ли транзакции доступ к объекту в базе данных на лету.</p>
        <p>Протоколу не нужно заранее знать все запросы, которые будет выполнять транзакция.</p>
    </section>

    <section class="slide">
        <h1>Two Phase Locking</h1>

        <p>В соответствии с протоколом двухфазной блокировки транзакция обрабатывает свои блокировки в двух отдельных последовательных фазах во время выполнения транзакции:</p>

        <p>Фаза расширения (Growing phase): блокировки приобретаются, но блокировки не освобождаются (количество блокировок может только увеличиваться).</p>
        <p>Фаза сокращения (Shrinking phase): блокировки снимаются, новые блокировки не приобретаются.</p>
    </section>

    <section class="slide">
        <h1>Two Phase Locking</h1>

        <p>Двухфазные правила блокировки можно резюмировать следующим образом: никогда не устанавливать блокировку после того, как блокировка была снята</p>
        <p>Свойство сериализуемости (Serializability) гарантируется для расписания с транзакциями, подчиняющимися этому правилу.</p>
        <p>Как правило, без явных знаний у транзакции когда будет конец фазы 1, безопасно отпускать блокировки только тогда,
            когда транзакция завершила обработку и запросила COMMIT. В этом случае все блокировки могут быть сняты сразу (фаза 2).</p>
    </section>

    <section class="slide">
        <h1>Two Phase Locking</h1>

        <p>1. Two Phase Locking</p>
        <p>2. Conservative Two Phase Locking (Взятие всех необходимых блокировок до начала транзакции).</p>
        <p>3. Strict Two Phase Locking (Отпускаем блокировки на запись в конце транзакции, блокировки на чтение отпускать не все сразу во время Shrinking фазы).</p>
        <p>4. Strong Strict Two Phase Locking (Отпускаем все блокировки в конце транзакции).</p>
    </section>

    <section class="slide">
        <h1>Strong Strict Two Phase Locking</h1>

        <p>Strong Strict 2PL (SSPL, также известный как Rigorous 2PL) — это вариант 2PL, при котором транзакция снимает блокировки только после завершения.</p>
        <p>Расписание является строгим, если значение, записанное транзакцией, не читается и не перезаписывается другими транзакциями до тех пор, пока эта транзакция не завершится. Таким образом, в SS2PL нет фазы сжатия, как в обычном 2PL.</p>
        <p>Преимущество этого подхода в том, что СУБД не подвергается каскадным прерываниям (cascading aborts). СУБД также может отменить изменения прерванной транзакции, просто восстановив исходные значения измененных кортежей.</p>
    </section>

    <section class="slide">
        <h1>SS2PL</h1>

        <p>Сценарий взаимной блокировки (deadlock)</p>
        <p>Transaction 1 take lock on object 1.</p>
        <p>Transcation 2 take lock on object 2.</p>
        <p>Transaction 1 try take lock on object 2.</p>
        <p>Transcation 2 take lock on object 1.</p>
    </section>

    <section class="slide">
        <h1>SS2PL Deadlock Handling</h1>

        <p>Взаимная блокировка (Deadlock) — это цикл транзакций, ожидающих снятия блокировок друг другом.</p>
        <p>Варианты решения:</p>
        <p>1. Нахождение взаимных блокировок (Deadlock detection)</p>
	    <p>2. Предотвращение взаимных блокировок (Deadlock prevention)</p>
    </section>

    <section class="slide">
        <h1>Deadlock detection</h1>

        <p>СУБД создает граф ожидания (wait-for graph): узлы являются транзакциями и есть ребро от <b>Ti</b> к <b>Tj</b>, если транзакция <b>Ti</b> ожидает снятия блокировки транзакцией <b>Tj</b>.</p>
        <p>Система будет периодически проверять наличие циклов в графе ожидания, а затем принимать решение о том, какой узел стоит удалить из графа чтобы избавиться от цикла.</p>
    </section>

    <section class="slide">
        <h1>Deadlock detection</h1>

        <p>Когда СУБД обнаружит взаимоблокировку, она выберет узел (транзакцию) для отката, чтобы разорвать цикл.</p>
        <p>Транзакция может перезапуститься (restart) или прерваться (abort).</p>
        <p>Существует несколько свойств транзакции, которые следует учитывать при выборе какую транзакцию стоит остановить.</p>
        <p>Можно выбрать на сколько транзакцию стоит откатить, до самого начала или на какое то фиксированное количество запросов чтобы разорвать цикл.</p>
    </section>

    <section class="slide">
        <h1>Deadlock prevention</h1>

        <p>Когда txn пытается получить блокировку, удерживаемую другим txn, СУБД уничтожает один из них, чтобы предотвратить взаимоблокировку.</p>
        <p>Этот подход не требует графа ожидания или алгоритма обнаружения взаимных блокировок.</p>
    </section>

    <section class="slide">
        <h1>Deadlock prevention</h1>

        <p>Назначьте приоритеты на основе временных меток:</p>
        <p>Старая (Транзакция началась раньше) метка времени = более высокий приоритет (например, T1 > T2). </p>
    </section>

    <section class="slide">
        <h1>Deadlock prevention</h1>

    <p>Wait-Die (Old Waits for Young)</p>
    <p>Если запрашивающая транзакция имеет более высокий приоритет, чем удерживающая транзакция, то запрашивающая транзакция ожидает завершения удерживающей транзакции.</p>
    <p>В противном случае запрашивающая транзакция прерывается.</p>
    <p>Wound-Wait (Young Waits for Old): </p>
    <p>1. Если запрашивающая транзакция имеет более высокий приоритет, чем удерживающая транзакция, то удерживающая транзакция отменяется и снимает блокировку.</p>
    <p>2. В противном случае запрашивающая транзакция ожидает.</p>
    </section>

    <section class="slide">
        <h1>Deadlock prevention</h1>

        <p>При ожидании блокировки разрешено только одно направление.</p>
    </section>

    <section class="slide">
        <h1>Lock Granularities</h1>

        <p>Если транзакция хочет обновить один миллион кортежей, она должна запросить у диспетчера блокировок СУБД миллион блокировок.</p>
        <p>Чтобы избежать этих накладных расходов, СУБД может использовать иерархию блокировок (lock hierarchy), которая позволяет транзакции использовать более грубые блокировки в системе. Например, он может получить одну блокировку таблицы с одним миллионом кортежей вместо одного миллиона отдельных блокировок.</p>
        <p>Когда транзакция получает блокировку для объекта в этой иерархии, она неявно получает блокировки для всех своих дочерних элементов.</p>
    </section>

    <section class="slide">
        <h1>Lock Granularities</h1>

        <img style="width: 25%; height: auto;" src="pictures/lock_hierarchy.png"/>
    </section>

    <section class="slide">
        <h1>Intention Locks</h1>

        <p>Намеренные блокировки позволяют заблокировать узел более высокого уровня в общем или эксклюзивном режиме без необходимости проверки всех узлов-потомков.</p>
        <p>Если узел находится в режиме намерения, то явная блокировка выполняется на более низком уровне дерева.</p>

        <p>Intention-Shared (IS): указывает на явную блокировку в общем (Shared) режиме на более низком уровне иерархии.</p>
        <p>Intention-Exclusive (IX) - указывает на явную блокировку в эксклюзивном (Exclusive) или общем (Shared) режиме на более низком уровне.</p>
        <p>Shared+Intention-Exclusive (SIX) - поддерево с корнем в этом узле явно заблокировано в общем режиме (Shared) и на более низком уровне в эксклюзивном режиме (Exclusive).</p>
    </section>

    <section class="slide">
        <h1>Conclusion</h1>

        <p>Почти во всех современных СУБД поддерживается S2PL.</p>
        <p>Для устранения взаимных блокировок выбирается стратегия их периодического нахождения (Deadlock Detection).</p>
        <p>СУБД автоматически берет необходимые блокировки во время выполения запросов.</p>
    </section>

    <section class="slide">
        <h1>Questions ?</h1>
    </section>

    <div class="progress"></div>
    <script src="shower/shower.min.js"></script>

    <!--Video plugin-->
    <link rel="stylesheet" href="shower/shower-video.css">
    <script src="shower/shower-video.js"></script>
    <!--/Video plugin-->
</body>
</html>
