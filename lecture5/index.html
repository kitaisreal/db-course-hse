<!DOCTYPE html>
<html lang="en">
<head>
    <title>HSE DB Course. Lecture 5.</title>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="shower/themes/yandex/styles/screen-16x9.css">

    <style type="text/css">
        code { display: block; white-space: pre; background-color: #EEE; }
        p.cloud { text-align: center; line-height: 1.5; }
        p.cloud span { font-size: 13pt; color: gray; padding: 0 20px 0 20px; white-space: nowrap; }
   </style>
</head>
<body class="shower list">
    <header class="caption">
        <h1>Базы данных 2022</h1>
    </header>

    <section class="slide" id="cover">
        <h1 style="margin-top: 150px;">Лекция 5. Buffer pool.</h1>
    </section>

    <section class="slide">
        <h2>План</h2>
        <p>1. Database Storage.</p>
        <p>2. Buffer Pool.</p>
        <p>3. Locks. Latches.</p>
        <p>4. OS-page cache.</p>
        <p>5. Buffer replacement policies.</p>
    </section>

    <section class="slide">
        <h1>Database Storage</h1>
        <p>Компоненты СУБД управляют перемещением данных между энергонезависимой и энергозависимой памятью.
        Система не может работать с данными непосредственно на диске, без предварительного перемещения в энергозависимые хранилища.</p>
    </section>

    <section class="slide">
        <h1>Database Storage</h1>
        <img style="width: 80%; height: 80%;" src="pictures/buffer_pool.png"/>
    </section>

    <section class="slide">
        <h1>Database Storage. Spatial Control</h1>
        <p>Куда записывать страницы на диск.</p>
        <p>Цель состоит в том, чтобы сохранить страницы, которые часто используются вместе, как физически как можно ближе друг к другу на диске.</p>
    </section>

    <section class="slide">
        <h1>Database Storage. Temporal Control</h1>

        <p>Когда читать страницы в память, а когда записывать их на диск.</p>
        <p>Цель состоит в том, чтобы свести к минимуму количество остановок при чтении данных с диска.</p>
    </section>

    <section class="slide">
        <h1>Buffer Pool Organization</h1>
        <p>Организован как массив фиксированного размера.</p>
        <p>Элемент массива называется frame.</p>
        <p>Когда СУБД запрашивает страницу, в один из этих фреймов помещается ее точная копия.</p>
    </section>

    <section class="slide">
        <h1>Buffer Pool Organization</h1>

        <img style="width: 80%; height: 80%;" src="pictures/buffer_pool_1.png"/>
    </section>

    <section class="slide">
        <h1>Buffer Pool Organization</h1>

        <img style="width: 80%; height: 80%;" src="pictures/buffer_pool_2.png"/>
    </section>

    <section class="slide">
        <h1>Buffer Pool. Page table.</h1>
        <p>Таблица страниц отслеживает страницы, которые в данный момент находятся в памяти.</p>
        <p>Также поддерживает дополнительные метаданные на страницу:</p>
        <p>1. Dirty flag</p>
        <p>2. Pin reference</p>
    </section>

    <section class="slide">
        <h1>Buffer Pool. Page table.</h1>

        <img style="width: 80%; height: 80%;" src="pictures/buffer_pool_3.png"/>
    </section>

    <section class="slide">
        <h1>Page directory</h1>

        <p>Каталог страниц — это сопоставление идентификаторов страниц, с расположением страниц в файлах базы данных.</p>
        <p>Все изменения должны быть записаны на диск, чтобы СУБД могла прочитать распложение страниц при перезапуске.</p>
    </section>

    <section class="slide">
        <h1>Page directory</h1>

        <img style="width: 80%; height: 80%;" src="pictures/page_directory.png"/>
    </section>

    <section class="slide">
        <h1>Page table</h1>

        <p>Таблица страниц — это сопоставление идентификаторов страниц с копиями страниц в буферном пуле.</p>
        <p>Это структура данных в памяти, которую не нужно храниться на диске.</p>
    </section>

    <section class="slide">
        <h1>Locks</h1>
        <p>Защищает логическое содержимое базы данных от других транзакций.</p>
        <p>Удерживается на время транзакции.</p>
        <p>Должна быть возможность отката изменений.</p>
    </section>

    <section class="slide">
        <h1>Latches</h1>
        <p>Защищает критические разделы внутренней структуры данных СУБД от других потоков.</p>
        <p>Удерживается на время операции.</p>
        <p>Не нужно иметь возможность откатить изменения.</p>
        <p>Аналог mutex.</p>
    </section>

    <section class="slide">
        <h1>Allocation policies</h1>

        <p>Глобальные политики:</p>
        <p>1. Принимать решения для всех активных транзакций.</p>
        <p>Локальные политики:</p>
        <p>1. Аллоцировать страницы для определенной транзакции, без учета поведения параллельных транзакций.</p>
        <p>2. Необходимо поддерживать обмен страницами.</p>
    </section>

    <section class="slide">
        <h1>Buffer pool optimizations</h1>

        <p>Иметь множество буферных пулов (например свой для каждой таблицы).</p>
        <p>Предварительная выборка (Prefetch)</p>
        <p>Использовать сканирование другого запроса (Scan sharing).</p>
        <p>Читать в обход буферного пула (Buffer Pool bypass).</p>
    </section>

    <section class="slide">
        <h1>Multiple buffer pools</h1>

        <p>СУБД не всегда имеет один буфер пул для всей системы.</p>
        <p>1. Несколько экземпляров буферного пула</p>
        <p>2. Пул буферов для каждой базы данных</p>
        <p>3. Пул буферов для отдельных страниц</p>
        <p>Помогает уменьшить конкуренцию (contention) и улучшить локальность данных (data locality).</p>
    </section>

    <section class="slide">
        <h1>Prefetch</h1>

        <p>СУБД также может выполнять предварительную выборку страниц на основе плана запроса.</p>
        <p>1. Последовательное сканирование (Sequential scan).</p>
        <p>2. Сканирование индекса (Index scan).</p>
    </section>

    <section class="slide">
        <h1>Scan sharing</h1>

        <p>Запросы могут повторно использовать данные, извлеченные из хранилища или вычисленные операторами. Это отличается от кэширования результатов.</p>
        <p>Разрешить нескольким запросам прикрепляться к одному курсору который сканирует таблицу.</p>
        <p>1. Запросы не обязательно должны быть одинаковыми.</p>
        <p>2. Возможен обменн промежуточными результатами.</p>
    </section>

    <section class="slide">
        <h1>Scan sharing</h1>

        <p>Если запрос запускает сканирование и сканирование данных другим запросом уже происходит, то СУБД подключится к курсору второго запроса.</p>
        <p>СУБД отслеживает, где присоединился второй запрос с первым, чтобы он мог завершить сканирование, когда достигнет конца структуры данных.</p>
        <p>Поддерживается в IBM DB2, MSSQL. Oracle поддерживает совместное использование курсора только для идентичных запросов.</p>
    </section>

    <section class="slide">
        <h1>Buffer pool bypass</h1>

        <p>Оператор последовательного сканирования не будет сохранять извлеченные страницы в пуле буферов, чтобы избежать накладных расходов.</p>
        <p>1. Память локальна для выполняющегося запроса.</p>
        <p>2. Хорошо работает, если оператору необходимо прочитать большую последовательность страницы, расположенные рядом на диске.</p>
        <p>3. Может использоваться для временных данных (сортировка, объединение).</p>
    </section>

    <section class="slide">
        <h1>OS page cache</h1>

        <p>Большинство операций с дисками проходят через OS API. Если вы не запретите это, ОС поддерживает собственный кеш файловой системы.</p>
        <p>Большинство СУБД используют прямой ввод-вывод (O_DIRECT) для обхода кэша ОС.</p>
        <p>1. Избавляемся от избыточных копий страниц.</p>
        <p>2. Можем поддерживать различные правила выселения.</p>
    </section>

    <section class="slide">
        <h1>Buffer replacement policies</h1>

        <p>Когда СУБД необходимо освободить frame, чтобы освободить место для новой страницы, она должна решить, какую страницу исключить из пула буферов.</p>
        <p>Цели:</p>
        <p>1. Правильность (Correctness).</p>
        <p>2. Точность (Accuracy).</p>
        <p>3. Скорость (Speed).</p>
        <p>4. Накладные расходы на метаданные для frame (Meta-data overhead).</p>
    </section>

    <section class="slide">
        <h1>LRU</h1>

        <p>Сохраняйте отметку времени последнего доступа к каждой странице.</p>
        <p>Когда СУБД необходимо удалить страницу, следует выбрать страницу с самой старой отметкой времени.</p>
        <p>Можно хранить страницы в отсортированном по отметки времени доступа порядке, чтобы сократить время поиска при выселении.</p>
    </section>

    <section class="slide">
        <h1>Clock</h1>

        <p>Аппроксимация LRU без необходимости отдельной метки времени на страницу.</p>
        <p>Каждая страница имеет контрольный бит.</p>
        <p>При доступе к странице устанавливаем зачение бита в 1.</p>
        <p>Организуйте страницы в круговом буфере, обходим страницы по часовой стрелке.</p>
        <p>Во время обхода проверяем, равно ли значение бита страницы 1. Если да, сбрасываем до 0. Если нет вытесняем страницу.</p>
    </section>

    <section class="slide">
        <h1>Sequential flooding</h1>
        <p>Политики замены LRU и CLOCK подвержены последовательному затоплению (Sequential flooding).</p>
        <p>Запрос выполняет последовательное сканирование, которое считывает каждую страницу.</p>
        <p>Это загрязняет буферный пул страницами, которые читаются один раз и больше никогда.</p>
        <p>Последняя использованная страница на самом деле является самой ненужной страницей.</p>
    </section>

    <section class="slide">
        <h1>LRU-K</h1>

        <p>СУБД отслеживайте историю последних K обращений к страницам</p>
        <p>LRU-K вытесняет страницу, чей K-й последний доступ является самым дальним в прошлом.</p>
        <p>Например, LRU-1 — это просто LRU, тогда как LRU-2 вытесняет страницы в соответствии со временем их предпоследнего доступа.</p>
    </section>

    <section class="slide">
        <h1>Localization</h1>

        <p>СУБД выбирает какие страницы вытеснять в зависимости от их локальности относительно транзакции, запросов.</p>
        <p>Следит за страницами, к которым обращался запрос.</p>
    </section>

    <section class="slide">
        <h1>Priorirty Hints</h1>

        <p>СУБД знает, каков контекст каждой страницы во время выполнения запроса.</p>
        <p>СУБД может давать подсказки буферному пулу о том, важна страница или нет.</p>
    </section>

    <section class="slide">
        <h1>Dirty pages</h1>

        <p>Fast: Если страница в пуле буферов не загрязнена, то СУБД может просто вытеснить ее.</p>
        <p>Slow: Если страница dirty, СУБД должна выполнить обратную запись на диск, чтобы убедиться, что ее изменения сохраняются.</p>
        <p>Компромисс между быстрым вытеснением страниц и множеством dirty страниц на запись, которые не будут прочитаны в будущем.</p>
    </section>

    <section class="slide">
        <h1>Background writing</h1>

        <p>СУБД может периодически просматривать таблицу страниц (page table) и записывать грязные страницы на диск.</p>
        <p>Когда грязная страница безопасно записана, СУБД может либо удалить страницу, либо просто снять грязный флаг.</p>
        <p>Нужно быть осторожным, чтобы не написать грязные страницы до того, как их произойдет запись информации о странице в журнал</p>
    </section>

    <section class="slide">
        <h1>Other memory pools</h1>
        <p>СУБД нужна память не только для кортежей и индексов, но и для других вещей.</p>
        <p>Эти другие пулы памяти могут быть как в основной памяти, так и храниться на диске. Зависит от реализации.</p>
        <p>1. Сортировка + объединение буферов</p>
        <p>2. Кэши результатов запросов</p>
        <p>3. Буферы обслуживания</p>
        <p>4. Буферы журнала</p>
    </section>

    <section class="slide">
        <h1>Conclusion</h1>

        <p>СУБД может управлять кэшированием страниц лучше чем ОС.</p>
        <p>Используя семантику плана запроса, чтобы принимать более взвешенные решения:</p>
        <p>1. Вытеснения страниц из кэша</p>
        <p>2. Распределения страниц в кэше</p>
        <p>3. Предварительная выборка (Prefetch)</p>
    </section>

    <section class="slide">
        <h1>Вопросы ?</h1>
    </section>

    <div class="progress"></div>
    <script src="shower/shower.min.js"></script>

    <!--Video plugin-->
    <link rel="stylesheet" href="shower/shower-video.css">
    <script src="shower/shower-video.js"></script>
    <!--/Video plugin-->
</body>
</html>
